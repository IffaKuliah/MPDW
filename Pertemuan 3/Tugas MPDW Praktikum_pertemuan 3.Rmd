---
title: "TUGAS MANDIRI PRAKTIKUM MPDW"
author: "Muthi'ah Iffa Karimah"
date: "2025-09-09"
output: html_document
---

# Input Data

```{r}
data_udara<- read.csv("C:\\Users\\MUTHI'AH IFFA\\Downloads\\Semester 5\\MPDW\\Praktikum\\Minggu 3\\NewDelhi_Air_quality.csv", header = TRUE, sep = ",")
data_udara
```

## Persiapan Data

```{r}
# Install package jika belum ada install.packages(c("ggplot2","tseries","dynlm","dLagM","lmtest","forecast")) 

# Load library
library(ggplot2)
library(tseries)
library(dynlm)
library(dLagM)
library(lmtest)
library(forecast)
library(xts)
library(forecast)
library(zoo)
library(car)
library(dynlm)
library(ARDL)
```

## Eksplorasi Data

```{r}
str(data_udara)
```

```{r}
# Buat data subset hanya AQI dan O3
aqi_o3 = data.frame(
  datetime = as.POSIXct(data_udara$ts, origin="1970-01-01", tz="UTC"),
  AQI = data_udara$AQI,
  O3  = data_udara$o3
)
aqi_o3
```

Dalam tugas ini akan diambil peubah Y adalah nilai AQI dan peubah x nya adalah O3 (ozon). Meski ozon berperan sebagai pelindung di atmosfer bumi, namun ozon akan menjadi berbahaya jika berada di dalam tanah. Karena ozon di dalam tanah terbentuk dari Nitrogen Oksida (NOx) serta senyawa organik volatil (VOC) yang berasal dari pembakaran bahan bakar fosil serta aktivitas manusia. Unsur-unsur ini besifat reakti, mudah bereaksi dengan bahan lain dan bersifat korosif dan berbau menyengat. Sehingga akan berbahaya bila terhirup i konsentrasi tinggi terutama di dekat permukaan, termasuk di dalam tanah.\

```{r}
library(performance)
library(see)

# Fit model linear
model = lm(AQI ~ O3, data = aqi_o3)

# Buat diagnostic plot
check_model(model)

```

```{r}
# 1. Plot Time Series AQI
ggplot(aqi_o3, aes(x = datetime, y = AQI)) +
  geom_line(color = "blue", linewidth = 1) +
  labs(title = "Time Series AQI", x = "Waktu", y = "AQI") +
  theme_minimal()
```

```{r}
# 2. Plot Time Series O3
ggplot(aqi_o3, aes(x = datetime, y = O3)) +
  geom_line(color = "red", linewidth = 1) +
  labs(title = "Time Series O3", x = "Waktu", y = "O3") +
  theme_minimal()
```

```{r}
# 3. Gabungan AQI & O3
ggplot(aqi_o3, aes(x = datetime)) +
  geom_line(aes(y = AQI, color = "AQI"), linewidth = 1) +
  geom_line(aes(y = O3, color = "O3"), linewidth = 1) +
  labs(title = "Time Series AQI dan O3", x = "Waktu", y = "Nilai") +
  scale_color_manual(values = c("AQI" = "blue", "O3" = "red")) +
  theme_minimal()
```

```{r}
# 4. Scatterplot Hubungan AQI vs O3
ggplot(aqi_o3, aes(x = O3, y = AQI)) +
  geom_point(color = "black", size = 2, alpha = 0.7) +
  geom_smooth(method = "lm", se = FALSE, color = "red") +
  labs(title = "Scatterplot Hubungan AQI vs O3",
       x = "O3", y = "AQI") +
  theme_minimal()
```

Nilai p-value \> 0.05 yaitu, 2.2e-16 artinya ada hubungan yang signifikan antara AQI dengan O3

Dari kedua nilai di atas, menunjukkan bahwa adanya hubungan linear yang cukup kuat dan signifikan antara kadar O3 dengan nilai AQI. Artinya, variasi O3 dapat menjelaskan perubahan dalma nilai AQi.

#### Statistik Deskriptif

```{r}
summary(subset(aqi_o3, select = -datetime))
```

#### Distribusi Data

```{r}
# Histogram
ggplot(aqi_o3, aes(x = AQI)) +
  geom_histogram(bins = 15, fill="blue", alpha=0.6) +
  labs(title="Distribusi AQI") +
  theme_minimal()
```

```{r}
ggplot(aqi_o3, aes(x = O3)) +
  geom_histogram(bins = 15, fill="red", alpha=0.6) +
  labs(title="Distribusi O3") +
  theme_minimal()
```

```{r}
# Boxplot (cek outlier)
ggplot(aqi_o3, aes(y = AQI)) +
  geom_boxplot(fill="skyblue") +
  labs(title="Boxplot AQI") +
  theme_minimal()
```

```{r}
ggplot(aqi_o3, aes(y = O3)) +
  geom_boxplot(fill="orange") +
  labs(title="Boxplot O3") +
  theme_minimal()
```

#### Autokorelasi (ACF)

```{r}
# Cek asumsi autokorelasi dengan ACF
acf(aqi_o3$AQI, main="ACF AQI")
acf(aqi_o3$O3, main="ACF O3")
```

Baik ACF untuk O3 dan AQI keduanya terindikasi autokorelasi

#### Lag Scatterplot

```{r}
# misal lag 1 untuk O3
lag1_O3 <- stats::lag(aqi_o3$O3, -1)
plot(lag1_O3, aqi_o3$AQI,
     main="AQI vs O3 lag 1",
     xlab="O3 (t-1)", ylab="AQI",
     pch=19, col="forestgreen")
```

Berdasarkan scatterplot AQI vs O3 adalah linear

### Boxplot

```{r}
# Boxplot Distribusi AQI (dengan boxplot per jam)
aqi_o3$hour <- format(aqi_o3$datetime, "%H")

ggplot(aqi_o3, aes(x = hour, y = AQI)) +
  geom_boxplot(fill="red") +
  labs(title="Distribusi AQI per Jam") +
  theme_minimal()
```

```{r}
# Boxplot Distribusi O3 (dengan boxplot per jam)
ggplot(aqi_o3, aes(x = hour, y = O3)) +
  geom_boxplot(fill="blue") +
  labs(title="Distribusi O3 per jam") +
  theme_minimal()
```

Data AQI dan O3 yang tercatat perjam cenderung memiliki fluktuasi yang tajam terutama id malam hari. Bisa jadi hal ini disebabkan oleh aktivitas manusia dan dinamika atmosfer harian.

### Cek Seasonal

```{r}
# Ubah data jadi ts (misal datanya harian dengan periode mingguan = 7)
aqi_ts <- ts(aqi_o3$AQI, frequency = 7)

# Decompose
decomp <- decompose(aqi_ts, type = "additive")
plot(decomp)
```

```{r}
# Pola musiman AQI 
aqi_ts <- ts(aqi_o3$AQI, frequency = 12) # contoh bulanan
ggseasonplot(aqi_ts, year.labels = TRUE, main = "Seasonal Plot AQI")
```

Plot di atas adalah pola musiman bulanan untuk beberapa tahun. Plot tersebut menunjukkan bahwa terindikasi adanya musiman yang di awal tahun nilai AQI meningkat, kemudian di pertengahan tahun nilai AQI memuncak dan mencapa titik tertinggi, dan di akhir tahun menurun kembali.

```{r}
# Hitung rolling variance (window 12, misal bulanan)
aqi_var <- rollapply(aqi_o3$AQI, width=12, FUN=var, fill=NA, align="right")
o3_var  <- rollapply(aqi_o3$O3,  width=12, FUN=var, fill=NA, align="right")
```

```{r}
# Plot rolling variance
plot(o3_var,  type="l", col="red",  main="Rolling Variance O3", ylab="Variance", xlab="Index")
```

```{r}
# Plot rolling variance
plot(aqi_var, type="l", col="blue", main="Rolling Variance AQI", ylab="Variance", xlab="Index")
```

# Cek Asumsi

H0: Data tidak stationer (ada unit root)

H1: Data stationer

p-value \< 0.05 tolak H0

```{r}
# Regresi linear sederhana
model = lm(AQI ~ O3, data = aqi_o3)
summary(model)
```

```{r}
# Uji stationer 
# Konversi ke time series
aqi_ts <- ts(aqi_o3$AQI, frequency = 12)
o3_ts  <- ts(aqi_o3$O3, frequency = 12)

# Uji stasioneritas dengan ADF
adf_aqi = adf.test(na.omit(aqi_ts))
adf_o3 = adf.test(na.omit(o3_ts))

adf_aqi
adf_o3

if(adf_aqi$p.value < 0.05){
  cat("AQI stasioner (p =", adf_aqi$p.value, ")\n")
} else {
  cat("AQI TIDAK stasioner (p =", adf_aqi$p.value, ")\n")
}

if(adf_o3$p.value < 0.05){
  cat("O3 stasioner (p =", adf_o3$p.value, ")\n")
} else {
  cat("O3 TIDAK stasioner (p =", adf_o3$p.value, ")\n")
}

```

```{r}
# Uji Heteroskeditas
bp = bptest(model)
bp 

if(bp$p.value < 0.05){
  cat("Heteroskedastisitas TERDETEKSI (p =", bp$p.value, ")\n")
} else {
  cat("Tidak ada heteroskedastisitas (p =", bp$p.value, ")\n")
}

```

```{r}
dw = dwtest(model)
dw

if(dw$p.value < 0.05){
  cat("Autokorelasi TERDETEKSI (p =", dw$p.value, ")\n")
} else {
  cat("Tidak ada autokorelasi (p =", dw$p.value, ")\n")
}
```

#### Transformasi peubah X dan Y

```{r}
# Transformasi log 
aqi.log = log(aqi_o3$AQI)
o3.log  = log(aqi_o3$O3)

# Uji stationer
model.log = lm(aqi.log~ o3.log, data = aqi_o3)
summary(model.log)
```

#### Uji asumsi ulang

```{r}
# Uji Stationer
adf.aqi2 = adf.test(na.omit(aqi.log))
adf.o32 = adf.test(na.omit(o3.log))
adf.aqi2
adf.o32

cat("Stasioner logAQI:", ifelse(adf.aqi2$p.value < 0.05, "✅ Stasioner", "❌ Tidak Stasioner"),
    "(p =", adf.aqi2$p.value, ")\n")
cat("Stasioner logO3 :", ifelse(adf.o32$p.value < 0.05, "✅ Stasioner", "❌ Tidak Stasioner"),
    "(p =", adf.o32$p.value, ")\n")


```

```{r}
# Uji heteroskeditas
bp2 = bptest(model.log)
cat("Heteroskedastisitas:", ifelse(bp$p.value > 0.05,
    "✅ Tidak ada heteroskedastisitas",
    "❌ Ada heteroskedastisitas"),
    "(p =", bp$p.value, ")\n")
```

```{r}
# Uji Autokorelasi
dw2 = dwtest(model.log)
cat("Autokorelasi:", ifelse(dw$p.value > 0.05,
    "✅ Tidak ada autokorelasi",
    "❌ Autokorelasi terdeteksi"),
    "(p =", dw$p.value, ")\n")

```

```{r}
# Uji Normalitas
shapiro = shapiro.test(residuals(model.log))
cat("Normalitas residual:", ifelse(shapiro$p.value > 0.05,
    "✅ Residual berdistribusi normal",
    "❌ Residual tidak normal"),
    "(p =", shapiro$p.value, ")\n")
```

### Penangan Autokorelasi

```{r}
# Install jika belum ada
# install.packages("orcutt")

library(orcutt)

# Model awal (sudah log transform)
model.log = lm(aqi.log ~ o3.log, data = aqi_o3)

# Terapkan Cochrane-Orcutt
co_model = cochrane.orcutt(model.log)

summary(co_model)

```

```{r}
# Uji lagi autokorelasi
library(lmtest)
dw_co = dwtest(co_model)
cat("Autokorelasi setelah Cochrane-Orcutt:",
    ifelse(dw_co$p.value > 0.05, "✅ Tidak ada autokorelasi",
           "❌ Autokorelasi masih ada"),
    "(p =", dw_co$p.value, ")\n")

```

### Penanganan Normalitas Residual

```{r}
library(MASS)

# Box-Cox untuk cari lambda terbaik
boxcox(model.log, lambda = seq(-2, 2, 0.1))

# Misal dari grafik, lambda ≈ 0 (log) atau 0.5 (sqrt)
# Kalau misal λ=0.5 → transformasi sqrt
aqi_o3$AQI_sqrt = sqrt(aqi_o3$AQI)
aqi_o3$O3_sqrt  = sqrt(aqi_o3$O3)

model.sqrt = lm(AQI_sqrt ~ O3_sqrt, data = aqi_o3)
summary(model.sqrt)
```

```{r}
# Cek normalitas residual lagi
shapiro = shapiro.test(residuals(model.sqrt))
cat("Normalitas residual setelah transformasi:",
    ifelse(shapiro$p.value > 0.05,
           "✅ Residual normal",
           "❌ Residual tidak normal"),
    "(p =", shapiro$p.value, ")\n")

```

```{r}
# Differencing pada O3 log
o3.diff = diff(o3.log)   # langsung diff vektor o3.log

# Uji ADF pada hasil differencing
library(tseries)
adf_o3_diff = adf.test(na.omit(o3.diff))

cat("Stasioner log(O3) differenced:",
    ifelse(adf_o3_diff$p.value < 0.05,
           "✅ Stasioner",
           "❌ Tidak stasioner"),
    "(p =", adf_o3_diff$p.value, ")\n")
```

```{r}
par(mfrow=c(2,2))
plot(model.log)
```

# Pembagian Data

```{r}
n = (aqi_o3)
n
```

```{r}
library(dynlm)
library(dplyr)
library(lmtest)
library(Metrics)
```

```{r}
# Buat dataframe log
df_log = data.frame(
  AQI_log = log(aqi_o3$AQI),
  O3_log  = log(aqi_o3$O3)
)

# split data 
n = nrow(df_log) 
train_n = floor(0.7 * n) 
train = df_log[1:train_n, ]
test  = df_log[(train_n+1):n, ]

train_ts <- ts(train, frequency = 12)
test_ts  <- ts(test, frequency = 12)
```

Proporsi 70:30 dipilih karena jumlah data relatif kecil (72 observasi), sehingga 30% uji (22 data) memberikan evaluasi lebih reliabel dibanding hanya 20% uji (14 data). Ini menjaga keseimbangan antara data latih yang cukup untuk membangun model dan data uji yang cukup untuk mengukur kinerja model.

```{r}
# Data time series
train_ts = ts(train)
test. = ts(test)
data.ts = ts(df_log)

```

# Koyck

### Pemodelan

```{r}
# MODEL KOYCK
model.koyck = koyckDlm(x = train$O3_log, y = train$AQI_log)
summary(model.koyck)
```

```{r}
AIC(model.koyck)
```

```{r}
BIC(model.koyck)
```

hasil summary didapatkan Y_duga_t = -0.33478 + 0.54519Xt + 0.42859Yt

-   Koefisien Xt (0.54519) signifikan, artinya X berpengaruh terhaadp U

-   Koefisien Yt-1 (0.42859) signifikan, ini merupakan estimasi untuk λ. Nilai ini menunjukkan sekitar 42% dari efek di periode sebelumnya masih "terbawa" saat ini

### Peramalan dan Akurasi

```{r}
# Peramalan y untuk 5 periode kedepan dengan menggunakan model koyck
library(dLagM)
fore.koyck = dLagM::forecast(model = model.koyck, x = train$O3_log, h = 5) # Membandingkan dengan data testing 
fore.koyck
```

```{r}
# Cek nilai MAPE
mape.koyck = MAPE(model.koyck)
mape.koyck #data test
```

```{r}
# Akurasi ata training
GoF(model.koyck)
```

# Regression with Distributed Lag

### Pemodelan (Lag = 2)

```{r}
model.dlm = dlm(x = train$O3_log, y = train$AQI_log, q = 1)
summary(model.dlm)
```

```{r}
model.dlm = dlm(x = train$O3_log, y = train$AQI_log, q = 2)
summary(model.dlm)
```

```{r}
AIC(model.dlm)
BIC(model.dlm)
```

### Peramalan dan Akurasi

```{r}
fore.dlm = dLagM::forecast(model = model.dlm, x = train$O3_log, h = 5) # Membandingkan dengan data testing 
fore.dlm
```

```{r}
mape.dlm = MAPE(model.dlm)
mape.dlm
```

### Lag Optimum

kita dapat meminta R untuk mencari nilai yang optimal secara otomatis berdasarkan kriteria informasi seperti AIC. AIC menyeimbangkan antara kecocokan model dengan kompleksitasnya.

```{r}
train_sub <- train[, c("AQI_log", "O3_log")]
# Penentuan Lag Optimum
finiteDLMauto(formula = AQI_log ~ O3_log,
              data = train_sub, q.min = 1, q.max = 10,
              model.type = "dlm", error.type = "AIC", trace = TRUE)

```

```{r}
model.dlm2 = dlm(x = train$O3_log, y = train$AQI_log, q = 10)
summary(model.dlm2)
```

```{r}
AIC(model.dlm2)
BIC(model.dlm2)
```

Yt\^= -0.7913 + 0.82878Xt + ... -0.22661Xt−10 adalah model akhir yang dihasilkan dari q = 10 dan dari model ini didapatkan beberapa peubah yang berpengaruh signifikan pada taraf nyata 5% yairu Xt, Xt-7, Xt-8, Xt-9, Xt-10.

```{r}
# peramalan 5 model kedepan dan akurasi 
fore.dlm2 = dLagM::forecast(model = model.dlm2, x = test$O3_log, h = 5)
fore.dlm2

```

```{r}
# Akurasi data training
GoF(model.dlm2)
```

```{r}
# MAPE 
mape.dlm2 = MAPE(model.dlm2)
mape.dlm2
```

# Autoregressive

### Pemodelan

```{r}
model.ardl = dLagM::ardlDlm(x = train$O3_log, y = train$AQI_log, p = 1, q = 1)
summary(model.ardl)
```

```{r}
AIC(model.ardl)
BIC(model.ardl)
```

### Peramalan dan Pemodelan

```{r}
# Koefisien hasil model
alpha <- -0.42361
beta0 <-  1.03217   # X_t
beta1 <- -0.49927   # X_(t-1)
phi1  <-  0.47048   # Y_(t-1)

# Simpan hasil forecast
h <- 5
y_fore <- numeric(h)

# Ambil nilai terakhir dari data training
last_y <- tail(train$AQI_log, 1)     # Y_(t)
last_y1 <- tail(train$AQI_log, 2)[1] # Y_(t-1)
last_x <- tail(train$O3_log, 1)      # X_(t)
last_x1 <- tail(train$O3_log, 2)[1]  # X_(t-1)

# Forecast 5 periode ke depan (pakai test$O3_log sebagai X masa depan)
for (i in 1:h) {
  x_now <- test$O3_log[i]             # X_t (baru)
  x_lag <- if (i == 1) last_x else test$O3_log[i-1]  # X_(t-1)
  
  y_fore[i] <- alpha + beta0*x_now + beta1*x_lag + phi1*last_y
  
  # update Y untuk periode berikutnya
  last_y <- y_fore[i]
}

# Hasil forecast
y_fore
fore.ardl <- list(forecasts = y_fore)
fore.ardl$forecasts

```

```{r}
# Hitung AIC dan BIC manual
resid <- residuals(model.ardl)
n <- length(resid)
SSR <- sum(resid^2)
k <- length(coef(model.ardl))   # jumlah parameter

AIC_manual <- n * log(SSR/n) + 2*k
BIC_manual <- n * log(SSR/n) + k*log(n)

AIC_manual
BIC_manual

```

```{r}
# Cek MAPE
# Ambil aktual 5 periode dari test set
y_actual <- test$AQI_log[1:5]

# Prediksi dari hasil manual forecast
y_pred <- y_fore

# Hitung MAPE
mape.ardl <- mean(abs((y_actual - y_pred) / y_actual)) * 100
mape.ardl


```

# Penentuan Lag Optimum

```{r}
model.ardl.opt = ardlBoundOrders(data = train, ic = "AIC", 
                                  formula = AQI_log ~ O3_log)

model.ardl.opt
```

```{r}
min_p=c()
for(i in 1:10){
  min_p[i]=min(model.ardl.opt$Stat.table[[i]])
}
q_opt=which(min_p==min(min_p, na.rm = TRUE))
p_opt=which(model.ardl.opt$Stat.table[[q_opt]] == 
              min(model.ardl.opt$Stat.table[[q_opt]], na.rm = TRUE))
data.frame("q_optimum" = q_opt, "p_optimum" = p_opt, 
           "AIC"=model.ardl.opt$min.Stat)
```

```{r}
model.ardl2 <- ardlDlm(formula = AQI_log ~ O3_log,
                         data = train, p = 10, q = 1)
summary(model.ardl2)
```

```{r}
# Cek AIC 
AIC(model.ardl2)
```

Berdasarkan hasil di atas terlihat bahwa nilai AIC terendah yaitu -404.8238 didapat ketika nilai optimum q =1 dan p = 2

# Perbandingan Model

```{r}
akurasi <- matrix(c(mape.koyck, 
                    mape.dlm, 
                    mape.dlm2,
                    mape.ardl))
row.names(akurasi)<- c("Koyck",
                       "DLM 1",
                       "DLM 2",
                       "Autoregressive")
colnames(akurasi) <- c("MAPE")
akurasi
```

MAPE terbaik adalah model DLM 2 karena memiliki nilai yang paling kecil.

### Plot

```{r}
# Ambil subset aktual (5 titik pertama test set)
y_actual <- test$AQI_log[1:5]
x_actual <- test$O3_log[1:5]

# Forecast dari semua model
y_koyck <- fore.koyck$forecasts
y_dlm1  <- fore.dlm$forecasts
y_dlm2  <- fore.dlm2$forecasts
y_ardl  <- fore.ardl$forecasts

# Plot aktual
plot(x_actual, y_actual, type="b", col="black", ylim=c(min(y_actual, y_koyck, y_dlm1, y_dlm2, y_ardl)-0.1, 
                                                      max(y_actual, y_koyck, y_dlm1, y_dlm2, y_ardl)+0.1),
     xlab="O3_log", ylab="AQI_log", main="Aktual vs Forecast (5 Periode Test)")

# Tambahkan hasil forecast
lines(x_actual, y_koyck, col="red", type="b", pch=19)
lines(x_actual, y_dlm1,  col="blue", type="b", pch=19)
lines(x_actual, y_dlm2,  col="orange", type="b", pch=19)
lines(x_actual, y_ardl,  col="green", type="b", pch=19)

# Legend
legend("topleft", c("Aktual", "Koyck", "DLM1", "DLM2", "ARDL"),
       col=c("black","red","blue","orange","green"), lty=1, pch=19, cex=0.8)

```

Berdasarkan data plot dari perbandingan model, model DLM terlihat cenderung mirip dengan data aktual. Sehingga dapat disimpulkan bahwa DLM adalah model terbaik karena juga memiliki nilai MAPE terkecil.
